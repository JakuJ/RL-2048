# -*- coding: utf-8 -*-
"""ntuple.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lQtPTdxrYo0yaqfMOkza2uJnM0mkJkMA
"""

import numpy as np
import matplotlib.pyplot as plt
from game import *

def normalize(value):
    """Map the 0 .. 2048 range to 0 .. 12"""
    return np.log2(np.maximum(value, 1))

class NTuple:
    def __init__(self, symmetries):
        self.n = 4
        self.m = 15
        k = self.m ** self.n
        self.lut = np.zeros((k,))
        self.symmetries = symmetries

    def get_indices(self, board):
        tuples = self.symmetries(board)
        lut_indices = []
        for indices in tuples:
            ix = 0
            for power, x in enumerate(indices):
                ix += normalize(x) * self.m ** power
            lut_indices.append(int(ix))
        return lut_indices
    
    def apply(self, board): # -> Y przewidziany
        indices = self.get_indices(board)
        return np.sum(self.lut[indices])

    def update(self, board, error): # Y prawdziwy -> [aktualizuje wagi]
        indices = self.get_indices(board)
        fraction = error / len(indices)
        for ix in indices:
            self.lut[ix] += fraction # pochodna błędu po wartości pod indeksem ix

def cols(board):
    return [board[:, 0], board[:, 1], board[:, 2], board[:, 3]]

def rows(board):
    return [board[0, :], board[1, :], board[2, :], board[3, :]]

def squares(board):
    xs = []
    for x in range(3):
        for y in range(3):
            xs.append(board[x:x+1,y:y+1])
    return xs

class NTupleNetwork:
    def __init__(self):
        self.tuples = [NTuple(cols), NTuple(rows), NTuple(squares)]
    
    def apply(self, board):
        return sum([s.apply(board) for s in self.tuples])
    
    def update(self, board, error):
        for t in self.tuples:
            t.update(board, error)
    
    def dump(self, iter_num, wins):
        np.savetxt(f"model/cols/{iter_num:06d}.txt", self.tuples[0].lut)
        with open(f"model/{iter_num:06d}.txt", "w") as file:
            file.write(str(self.tuples[0].lut))
        
        np.savetxt(f"model/rows/{iter_num:06d}.txt", self.tuples[1].lut)
        with open(f"model/{iter_num:06d}.txt", "w") as file:
            file.write(str(self.tuples[1].lut))

        np.savetxt(f"model/squares/{iter_num:06d}.txt", self.tuples[2].lut)
        with open(f"model/{iter_num:06d}.txt", "w") as file:
            file.write(str(self.tuples[2].lut))
        
        with open("model/stats.txt", "w") as file:
            file.write(str(wins))
        

def play_game(evaluate, learn=None):
    s = new_board()
    score = 0
    while not check_if_gameover(s):
        actions = list(possible_moves(s))
        a = sorted(actions, key=lambda a: evaluate(s, a), reverse=True)[0]
        s1, s2, r = swipe(s, a)
        
        if learn is not None:
            learn(s, a, r, s1, s2, evaluate)
        
        score += r
        s = s2
    return score, s

#model = NTuple(cols)
model = NTupleNetwork()

def evaluate_as(s, a):
    s1, _, r = swipe(s, a)
    return r + model.apply(s1)

def learn_as(s, a, r, s1, s2, evaluate):
    learning_rate = 0.01
    actions = list(possible_moves(s2))
    if not actions:
        return
    a_next = sorted(actions, key=lambda a: evaluate(s2, a), reverse=True)[0]
    s1_next, _, r_next = swipe(s2, a_next)
    model.update(s1, learning_rate * (r_next + (model.apply(s1_next) - model.apply(s1))/3))

wins = []
iter_num = 0
batch_size = 500
def pprint(board):
    for row in board:
        print(list(row))

def moving_average(a, n=3) :
    ret = np.cumsum(a, dtype=float)
    ret[n:] = ret[n:] - ret[:-n]
    return ret[n - 1:] / n

while True:    
    for i in range(1, 1 + batch_size):
        score, board = play_game(evaluate_as, learn_as)
        highest = np.max(board)    
        print(i + iter_num)
        #print(f"Score: {score}, max: {highest}")
        if highest >= 2048:
            wins.append(1)
        #    pprint(board)
        else:
            wins.append(0)
    iter_num += batch_size
    # plt.plot(moving_average(np.array(wins), 20))
    # plt.show()
    model.dump(iter_num,wins)

#plt.plot(moving_average(np.array(wins), 20))
#plt.show()
#
## Średni win-rate
#np.average(wins)

